2024-03-01 23:00:53,026 - PASCAL - INFO - 开始验证补丁1 1:
2024-03-01 23:00:53,026 - PASCAL - INFO - 
public class PASCAL {
    public static ArrayList<ArrayList<Integer>> pascal(int n) {
        ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> init = new ArrayList<Integer>();
        init.add(1);
        rows.add(init);
        for (int r = 1; r < n; r++) {
            ArrayList<Integer> row = new ArrayList<Integer>();
            row.add(1); // Add the initial 1 for each row
            for (int c = 1; c < r; c++) { // Start from 1 since we have already added the first element
                int upleft = rows.get(r - 1).get(c - 1);
                int upright = rows.get(r - 1).get(c);
                row.add(upleft + upright);
            }
            row.add(1); // Add the last 1 for each row
            rows.add(row);
        }
        return rows;
    }
}

2024-03-01 23:00:53,786 - PASCAL - INFO - 补丁1 1测试失败
2024-03-01 23:00:53,787 - PASCAL - INFO - 开始验证补丁1 2:
2024-03-01 23:00:53,787 - PASCAL - INFO - 
public class PASCAL {
    public static ArrayList<ArrayList<Integer>> pascal(int n) {
        ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();
        for (int r = 0; r < n; r++) {
            ArrayList<Integer> row = new ArrayList<Integer>();
            for (int c = 0; c <= r; c++) { // Changed the loop condition to c <= r to include the last element
                int upleft, upright;
                if (c > 0) {
                    upleft = rows.get(r - 1).get(c - 1);
                } else {
                    upleft = 0;
                }
                if (c < r) {
                    upright = rows.get(r - 1).get(c);
                } else {
                    upright = 0;
                }
                row.add(upleft + upright);
            }
            rows.add(row);
        }
        return rows;
    }
}

2024-03-01 23:00:54,599 - PASCAL - INFO - 补丁1 2测试失败
2024-03-01 23:00:54,600 - PASCAL - INFO - 开始验证补丁1 3:
2024-03-01 23:00:54,600 - PASCAL - INFO - 
public class PASCAL {
    public static ArrayList<ArrayList<Integer>> pascal(int n) {
        ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> init = new ArrayList<Integer>();
        init.add(1);
        rows.add(init);
        for (int r = 1; r < n; r++) {
            ArrayList<Integer> row = new ArrayList<Integer>();
            for (int c = 0; c <= r; c++) { // Changed the loop condition to c <= r
                int upleft, upright;
                if (c > 0) {
                    upleft = rows.get(r - 1).get(c - 1);
                } else {
                    upleft = 0;
                }
                if (c < r) {
                    upright = rows.get(r - 1).get(c);
                } else {
                    upright = 0;
                }
                row.add(upleft + upright);
            }
            rows.add(row);
        }
        return rows;
    }
}

2024-03-01 23:00:55,367 - PASCAL - INFO - 补丁1 3测试失败
2024-03-01 23:00:55,369 - PASCAL - INFO - 开始验证补丁1 4:
2024-03-01 23:00:55,369 - PASCAL - INFO - 
row.add(1); // Add the initial 1 for each row
for (int c=1; c<r; c++) { // Start from 1 since we have already added the first element
    int upleft = rows.get(r-1).get(c-1);
    int upright = rows.get(r-1).get(c);
    row.add(upleft + upright);
}
row.add(1); // Add the last 1 for each row

2024-03-01 23:00:56,172 - PASCAL - INFO - 补丁1 4测试失败
2024-03-01 23:00:56,173 - PASCAL - INFO - 开始验证补丁1 5:
2024-03-01 23:00:56,174 - PASCAL - INFO - 
row.add(1); // Add the initial 1 for each row
for (int c=0; c<r; c++) { 
    int upleft, upright;
    if (c > 0) {
        upleft = rows.get(r-1).get(c-1);
    } else {
        upleft = 0;
    }
    if (c < r) {
        upright = rows.get(r-1).get(c);
    } else {
        upright = 0;
    }
    row.add(upleft + upright);
}
row.add(1); // Add the last 1 for each row

2024-03-01 23:00:56,974 - PASCAL - INFO - 补丁1 5测试失败
2024-03-01 23:00:56,975 - PASCAL - INFO - 开始验证补丁1 6:
2024-03-01 23:00:56,975 - PASCAL - INFO - 
row.add(1); // Add the initial 1 for each row
for (int c=0; c<=r; c++) { 
    int upleft, upright;
    if (c > 0) {
        upleft = rows.get(r-1).get(c-1);
    } else {
        upleft = 0;
    }
    if (c < r) {
        upright = rows.get(r-1).get(c);
    } else {
        upright = 0;
    }
    row.add(upleft + upright);
}
row.add(1); // Add the last 1 for each row

2024-03-01 23:00:57,795 - PASCAL - INFO - 补丁1 6测试失败
2024-03-01 23:00:57,797 - PASCAL - INFO - 开始验证补丁1 7:
2024-03-01 23:00:57,797 - PASCAL - INFO - 
row.add(1); // Add the initial 1 for each row
for (int c=1; c<r; c++) { // Start from 1 since we have already added the first element
    int upleft = rows.get(r-1).get(c-1);
    int upright = rows.get(r-1).get(c);
    row.add(upleft + upright);
}
row.add(1); // Add the last 1 for each row

2024-03-01 23:00:57,797 - PASCAL - INFO - 补丁1 7为重复的补丁
2024-03-01 23:00:57,798 - PASCAL - INFO - 开始验证补丁1 8:
2024-03-01 23:00:57,798 - PASCAL - INFO - 
row.add(1); // Add the initial 1 for each row
for (int c=1; c<=r; c++) {
    int upleft = rows.get(r-1).get(c-1);
    int upright = rows.get(r-1).get(c);
    row.add(upleft + upright);
}
row.add(1); // Add the last 1 for each row

2024-03-01 23:00:58,572 - PASCAL - INFO - 补丁1 8测试失败
2024-03-01 23:00:58,573 - PASCAL - INFO - 开始验证补丁1 9:
2024-03-01 23:00:58,573 - PASCAL - INFO - 
row.add(1); // Add the initial 1 for each row
for (int c=1; c<r+1; c++) {
    int upleft = rows.get(r-1).get(c-1);
    int upright = rows.get(r-1).get(c);
    row.add(upleft + upright);
}
row.add(1); // Add the last 1 for each row

2024-03-01 23:00:59,367 - PASCAL - INFO - 补丁1 9测试失败
2024-03-01 23:00:59,368 - PASCAL - INFO - 开始验证补丁2 1:
2024-03-01 23:00:59,368 - PASCAL - INFO - 
for (int c=0; c<=r; c++) {
    int upleft, upright;
    if (c > 0) {
        upleft = rows.get(r-1).get(c-1);
    } else {
        upleft = 0;
    }
    if (c < r) {
        upright = rows.get(r-1).get(c);
    } else {
        upright = 0;
    }
    row.add(upleft+upright);
}

2024-03-01 23:01:00,152 - PASCAL - INFO - 补丁2 1测试失败
2024-03-01 23:01:00,153 - PASCAL - INFO - 开始验证补丁2 2:
2024-03-01 23:01:00,154 - PASCAL - INFO - 
for (int c=0; c<=r; c++) {
    int upleft = 0, upright = 0;
    if (c > 0) {
        upleft = rows.get(r-1).get(c-1);
    }
    if (c < r) {
        upright = rows.get(r-1).get(c);
    }
    row.add(upleft + upright);
}

2024-03-01 23:01:00,923 - PASCAL - INFO - 补丁2 2测试失败
2024-03-01 23:01:00,924 - PASCAL - INFO - 开始验证补丁2 3:
2024-03-01 23:01:00,924 - PASCAL - INFO - 
for (int c=0; c<=r; c++) {
    int upleft = 0, upright = 0;
    if (c > 0) {
        upleft = rows.get(r-1).get(c-1);
    }
    if (c < r) {
        upright = rows.get(r-1).get(c);
    }
    row.add(upleft + upright);
}

2024-03-01 23:01:00,924 - PASCAL - INFO - 补丁2 3为重复的补丁
2024-03-01 23:01:00,925 - PASCAL - INFO - 开始验证补丁2 7:
2024-03-01 23:01:00,925 - PASCAL - INFO - 
            for (int c=0; c<=r; c++) {

2024-03-01 23:01:02,017 - PASCAL - INFO - 补丁2 7 通过了所有的测试用例
